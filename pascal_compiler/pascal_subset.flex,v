head	1.7;
access;
symbols;
locks; strict;
comment	@# @;


1.7
date	97.06.03.06.39.17;	author exa;	state Exp;
branches;
next	1.6;

1.6
date	97.05.21.21.18.01;	author exa;	state Exp;
branches;
next	1.5;

1.5
date	97.05.20.21.28.40;	author exa;	state Exp;
branches;
next	1.4;

1.4
date	97.05.19.14.08.03;	author exa;	state Exp;
branches;
next	1.3;

1.3
date	97.05.18.19.18.22;	author exa;	state Exp;
branches;
next	1.2;

1.2
date	97.05.18.18.50.56;	author exa;	state Exp;
branches;
next	1.1;

1.1
date	97.05.17.21.31.32;	author exa;	state Exp;
branches;
next	;


desc
@@


1.7
log
@minor changes, div has a new token name.
@
text
@/*
** Lexical analyzer for compiler
**
** Flex source
**
** exa/analog
**
*/


%{
#include "General.hxx"
#include <ctype.h>
#include <iostream.h>
#include "pascal_subset.hxx"
#include "pascal_subset.tab.h"
int line_number = 1;
%}

/* Options */

%option never-interactive stack
%option nodefault
%option nodebug

/* Regular Definitions */

digit		[0-9]
digits		{digit}+
alpha		[A-Za-z\_]
alphanum	[0-9A-Za-z\_]

lit_int		{digits}
lit_float	{digits}(\.{digits})?(E[+-]?{digits})?
id		{alpha}{alphanum}*

punctuation     [\(\)\[\],:;\.]

/* REs that are removed from the source file */
white_space	[ \t]+

/* keyword successor */
ks		[ \t\n\(\)\[\],:;\.]

/* Start Conditions */
/* exclusive */
%x keyword non_keyword comment

/* Rules */

%%
.			yyless(0); BEGIN(keyword); 

<keyword>{
program/{ks}		return PROGRAM;
var/{ks}		return VAR;
array/{ks}		return ARRAY;
of/{ks}		        return OF;
integer/{ks}		return INTEGER;
real/{ks}		return REAL;
function/{ks}		return FUNCTION;
procedure/{ks}		return PROCEDURE;
begin/{ks}		return BLOCK_BEG;
end/{ks}		return BLOCK_END;
if/{ks}			return IF;
then/{ks}		return THEN;
else/{ks}		return ELSE;
while/{ks}		return WHILE;
do/{ks}			return DO;
\n                      line_number++;
{white_space}           /* consume white_space */
.			yyless(0); BEGIN(non_keyword);
}


<non_keyword>{

  {lit_int}		yylval.integer = atoi(yytext); return L_INT;
  {lit_float}		yylval.floating = atof(yytext); return L_FLOAT;

  \(			return LP;
  \)			return RP;
  \[                    return LB;
  \]                    return RB;
  ,			return COM;
  :			return COL;
  ;			return SC;
  \.                    return DOT;
  \.\.                  return DOTDOT;

  :=			return ASSIGN;
  =			return EQ;
  "<>"			return NE;
  "<"			return LT;
  "<="			return LE;
  ">"			return GT;
  ">="			return GE;

  \+			return ADD;
  \-			return SUB;
  \*			return MUL;
  \/                    return DIV;
  or			return OR;
  and			return AND;
  xor                   return XOR;
  div			return DIV2;
  mod			return MOD;
  not			return NOT;

  {id}			yylval.symbol = new Symbol(yytext); return ID;

  \n                    line_number++; BEGIN(keyword);
  \{			BEGIN(comment);		/* consume comments */
  {white_space}	        BEGIN(keyword);		/* and white space  */

  .			cout << "Unrecognized character: "<< yytext << endl;
}


<comment>{
  [^\{\}\n]+			                 /* inside comment */
  \{			cout << "comment error" << endl; /* syntax error */
  \}			BEGIN(keyword);		 /* end of comment */
  \n			line_number++;
}


%%

/* End of rules */

/* Additional C code */










@


1.6
log
@complete set of operator tokens.
@
text
@d12 2
d78 2
a79 2
  {lit_int}		return L_INT;
  {lit_float}		return L_FLOAT;
d91 1
a91 1
  :=			return ASSIGNOP;
d98 5
a102 4
  \+			return ADDOP;
  \-			return SUBOP;
  \*			return MULOP;
  \/                    return DIVOP;
d105 2
a106 1
  div			return DIV;
d110 1
a110 1
  {id}			return ID;
d122 1
a122 1
  \{			cout << "error" << endl; /* syntax error */
@


1.5
log
@corrected rule for DOTDOT
@
text
@d90 15
a104 2
  =|"<>"|<|"<="|">="|>	return RELOP;
  \+|\-|\*|\/|or|and|div|mod	return ARITHMOP;
d129 9
@


1.4
log
@reserved keywords added. correct handling of comment, keywords and non-keywords
now...
@
text
@d87 1
a87 1
  \..                   return DOTDOT;
@


1.3
log
@added tokens, have to handle reserved words and literals correctly though
@
text
@d5 3
d31 2
d34 2
a35 2
lit_int		{digits}
lit_float	{digits}(.{digits})?(E[+-]{digits})?
d40 3
d44 2
a45 3
/*%s*/
/* Exclusive Start Conditions */
%x comment
d50 1
d52 20
a71 2
{lit_float}		return L_FLOAT;
{lit_int}		return L_INT;
a72 2
\(			return LP;
\)			return RP;
d74 1
a74 18
program			return PROGRAM;
var			return VAR;
array			return ARRAY;
integer			return INTEGER;
real			return REAL;
function		return FUNCTION;
procedure		return PROCEDURE;
begin			return BLOCK_BEG;
end			return BLOCK_END;
if			return IF;
then			return THEN;
else			return ELSE;
while			return WHILE;
do			return DO;

:=			return ASSIGNOP;
=|"<>"|<|"<="|">="|>	return RELOP;
\+|\-|\*|\/|or|and|div|mod	return AOP;
d76 25
a100 1
{id}			return ID;
a101 1
<*>\n			line_number++; /* keep track of line numbers */
a102 1
\{			yy_push_state(comment);	/* consume comments */
d104 4
a107 3
  [^\{\}\n]+					/* inside of comment */
  \{			cout << "error" << endl;/* syntax error*/
  \}			yy_pop_state();		/* end of comment */
a109 3
{white_space}		/* eat up white space */

.			cout << "Unrecognized character: "<< yytext << endl;
@


1.2
log
@corrected comment stripper, replaced regular definitions comment_beg and
comment_end by their one character defs '\{' and '\}', this had to be
done due to a probable bug in flex version 2.5.2. The reason of the bug
is not appreciated.
@
text
@d19 1
a19 1
%option debug
d43 25
@


1.1
log
@Initial revision
@
text
@d15 6
d23 1
a23 1
digit		[[:digit:]]
d25 6
a30 1
id		[[:alpha:]][[:alnum:]]*
a33 2
comment_beg	\{
comment_end	\}
d37 1
d44 2
a45 1
{white_space}		/* eat up white space */
d48 8
a55 4
{comment_beg}		{ BEGIN(comment); /* consume comments */ }
<comment>[^{comment_beg}{comment_end}\n]*	/* inside of a comment */
<comment>{comment_beg}	/* syntax error*/
<comment>{comment_end}	BEGIN(INITIAL);
d57 1
a57 1
id			return ID;
@
