head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	97.06.03.06.37.00;	author exa;	state Exp;
branches;
next	1.4;

1.4
date	97.05.21.21.15.18;	author exa;	state Exp;
branches;
next	1.3;

1.3
date	97.05.20.21.31.53;	author exa;	state Exp;
branches;
next	1.2;

1.2
date	97.05.18.19.17.41;	author exa;	state Exp;
branches;
next	1.1;

1.1
date	97.05.17.21.32.19;	author exa;	state Exp;
branches;
next	;


desc
@@


1.5
log
@assignments, if while statements, compound statements, expressions augmented.
@
text
@/*
** Bison source for parser module of the compiler
**
** exa/AnaLoG
*/


/* C declarations */

%{
#define YYDEBUG 1
#include "General.hxx"
#include <stdio.h>
#include <iostream.h>
#include "pascal_subset.hxx"

// current context
Context *context;// = toplevel;

int yyerror(char *s);
%}


/* Types of tokens */

%union {
	int		integer;
	double		floating;
	Symbol		*symbol;
	SymbolList	*symbol_list;
	Type		*type;
	TypeList	*type_list;
	Variable	*variable;
	Constant	*constant;
	Expression	*expression;
	ExprList	*expr_list;
	ConstantExpression *const_expr;
	Statement	*statement;
	Context		*context;
}


/* Token Declarations */

/*
** Delimiters and Seperators 
** Left Paranthesis, Right Paranthesis, Left Bracket, Right Bracket,
** COMma, COLon, SemiColon, '.', '..'
*/
%token LP RP LB RB COM COL SC DOT DOTDOT

/* Reserved keywords */
%token PROGRAM VAR ARRAY OF INTEGER REAL FUNCTION PROCEDURE
%token BLOCK_BEG BLOCK_END IF THEN ELSE WHILE DO

/* Literals */
%token <integer> L_INT
%token <floating> L_FLOAT

/* Identifier */
%token <symbol> ID

/* Operators */

%nonassoc ASSIGN
%left OR AND XOR NOT
%left EQ NE LT LE GT GE
%left ADD SUB
%left MUL DIV
%left DIV2 MOD
%nonassoc UMINUS UPLUS

/* Types of non-terminals */

%type <context> program
%type <symbol_list> identifier_list
%type <type> type standart_type
%type <type_list> parameter parameter_list arguments
%type <variable> variable;
%type <const_expr> constant;
%type <expression> expression;
%type <expr_list> expression_list;
%type <statement> statement statement_list
%type <statement> optional_statements compound_statement;
%type <statement> if_statement while_statement

%%

/* LALR(1) Grammar together with S-attributed semantic rules */

program: /* entire program */
	{ $<context>$ = init_toplevel(); }
	PROGRAM ID LP identifier_list RP SC
	VAR variable_declarations
	subprogram_declarations
	compound_statement
	DOT
	{ ($$ = context)->generate_intermediate_code($11); }
	;

identifier_list:
	ID
	{ ($$ = new SymbolList)->add_tail($1); }
	| identifier_list COM ID
	{ $1->add_tail($3); $$ = $1; }
	;

variable_declarations:
	variable_declarations identifier_list COL type SC
	{ context->declare_variables(*$2, $4); }
	|
	;

type:
	standart_type { $$ = $1; }
	| ARRAY LB L_INT DOTDOT L_INT RB OF standart_type
	{ $$ = NULL; }
	;

standart_type:
	INTEGER { $$ = new IntegerType; }
	| REAL  { $$ = new RealType; }
	;

subprogram_declarations:
	subprogram_declarations subprogram_declaration
	|
	;

subprogram_declaration:
	subprogram_head
	variable_declarations
	compound_statement
	SC
	;

subprogram_head:
	FUNCTION ID arguments COL standart_type SC
	| PROCEDURE ID arguments SC
	;
		
arguments:
	LP parameter_list RP { $$ = $2; }
	| { $$ = new TypeList; }
	;

parameter_list:
	parameter
	{ $$ = $1; }
	| parameter_list SC parameter
	{ $1->add_tail(*$3); $$ = $1; }
	;

parameter:
	identifier_list COL type
	{ $$ = make_parameter(*$1, $3); }
	;

compound_statement:
	BLOCK_BEG optional_statements BLOCK_END
	{ $$ = $2; }
	;

optional_statements:
	statement_list
	{ $$ = $1; }
	|
	{ $$ = new Statement; }
	;

statement_list:
	statement { $$ = $1; }
	| statement_list SC statement
	{ $1->cat(*$3); $$=$1; }
	;

statement:
	variable ASSIGN expression
	{ $$ = context->assign($1, $3); }
	| procedure_statement {}
	| compound_statement { $$ = $1; }
	| if_statement { $$ = $1; }
	| while_statement {}
	;

if_statement:
	IF expression THEN statement ELSE statement
	{ $$ = context->if_else($2, $4, $6); }
	;

while_statement:
	WHILE expression DO statement
	{ $$ = context->while_stmt($2, $4); }
	;

procedure_statement:
	ID {}
	| ID LP expression_list RP {}
	;

expression_list:
	expression
	{ ($$ = new ExprList)->add_tail($1); }
	| expression_list COM expression
	{ $1->add_tail($3); $$ = $1; }
	;

/* expressions are variables with code generation capabilites */
expression:
	variable
	{ $$ = (Expression*)context->get_varexpr($1); }

	| constant
	{ $$ = (Expression*)$1; }

	| ID LP expression_list RP
	{ $$ = 0; }

	| expression EQ expression
	{ $$ = context->eqop($1, $3); }
	| expression NE expression
	{ $$ = context->neop($1, $3); }
	| expression LT expression
	{ $$ = context->ltop($1, $3); }
	| expression LE expression
	{ $$ = context->leop($1, $3); }
	| expression GT expression
	{ $$ = context->gtop($1, $3); }
	| expression GE expression
	{ $$ = context->geop($1, $3); }

	| expression ADD expression
	{ $$ = context->addop($1, $3); }
	| expression SUB expression
	{ $$ = context->subop($1, $3); }
	| expression MUL expression
	{ $$ = context->mulop($1, $3); }
	| expression DIV expression
	{ $$ = context->divop($1, $3); }

	| expression AND expression
	{ $$ = context->andop($1, $3); }
	| expression OR expression
	{ $$ = context->orop($1, $3); }
	| expression XOR expression
	{ $$ = context->xorop($1, $3); }
	| expression DIV2 expression
	{ $$ = context->div2op($1, $3); }
	| expression MOD expression
	{ $$ = context->modop($1, $3); }

	| ADD expression %prec UPLUS
	{ $$ = $2; }
	| SUB expression %prec UMINUS
	{ $$ = context->negop($2); }
	| NOT expression
	{ $$ = context->notop($2); }

	| LP expression RP
	{ $$ = $2; }
	;

variable:
	ID
	{ $$ = context->variable_ref($1); }
	| ID LB expression RB
	{ $$ = 0; }
	;

constant:
	L_INT
	{ $$ = context->get_constexpr($1); }
	| L_FLOAT
	{ $$ = context->get_constexpr($1); }
	;

/* End of Grammar */

%%

int yyerror(char *s)
{
  cerr << s << endl;
}

@


1.4
log
@grammar augmented with operator precedence declarations. all conflicts
eliminated. only EQ and ADDOP rules present tentatively.
@
text
@d4 1
a4 1
**
d12 1
d16 4
d27 13
a39 2
int integer;
float real;
a44 4
/* Literals */
%token L_INT
%token L_FLOAT

d47 1
a47 2
** Left Paranthesis, Right Paranthesis,
** Left Bracket, Right Bracket,
d50 1
a50 2
%token LP RP LB RB COM COL SC
%token DOT DOTDOT
d56 6
d65 1
a65 5
%nonassoc ASSIGNOP
%left EQ NE LT LE GT GE 
%left ADDOP SUBOP
%left MULOP DIVOP
%left DIV MOD
d67 4
d73 1
a73 7
/* ASSIGNment OPerator, RELational OPerators
%token ASSIGNOP RELOP ARITHMOP
%token UMINUS UPLUS
%token ADDOP SUBOP MULOP DIVOP
%token DIV MOD
%token OR AND XOR NOT
*/
d75 11
a85 2
/* Identifier */
%token ID
d89 1
a89 1
/* LALR(1) Grammar */
d91 2
a92 1
program:	/* entire program */
d94 1
a94 2
	VAR
	variable_declarations
d98 1
d103 1
d105 1
d110 1
d115 1
a115 1
	standart_type
d117 1
d121 2
a122 2
	INTEGER
	| REAL
d143 2
a144 2
	LP parameter_list RP
	|
d149 1
d151 1
d156 1
d161 1
d166 1
d168 1
d172 1
a172 1
	statement
d174 1
d178 16
a193 10
	variable ASSIGNOP expression
	| procedure_statement
	| compound_statement
	| IF expression THEN statement ELSE statement
	| WHILE expression DO statement
	;

variable:
	ID
	| ID LB expression RB
d197 2
a198 2
	ID
	| ID LP expression_list RP
d203 1
d205 1
d208 1
d210 6
a215 1
	ID
d217 2
a218 2
	| L_INT
	| L_FLOAT
d220 39
a258 1
	| expression ADDOP expression
d260 15
@


1.3
log
@made the grammar look more pascal like. now grammar has a single VAR body.
not multiple of them. also added seperate tokens for arithmetic and logic
operators, no precedence and associativity declarations yet.
@
text
@d49 9
a57 1
/* ASSIGNment OPerator, RELational OPerators */
d63 1
a169 5
	simple_expression
	| simple_expression RELOP simple_expression
	;

simple_expression:
d174 2
a175 1
	| expression ARITHMOP expression
@


1.2
log
@added tokens tentatively
@
text
@d7 3
d11 2
d18 1
d23 1
d26 3
d33 8
a40 2
/* Delimiters */
%token LP RP
d43 1
a43 1
%token PROGRAM VAR ARRAY INTEGER REAL FUNCTION PROCEDURE
d46 1
a47 1
%token ASSIGNOP RELOP AOP
d49 8
d64 108
@


1.1
log
@Initial revision
@
text
@d13 2
d18 14
@
