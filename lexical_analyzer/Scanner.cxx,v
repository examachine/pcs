head	1.1;
access;
symbols;
locks
	exa:1.1; strict;
comment	@// @;


1.1
date	98.03.29.21.08.21;	author exa;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
** Implementation file for Scannermodule
**
**
**
** exa
**
*/

#include "Scanner.hxx"

char* Scanner::token_names[]=
{"id", "intnum", "realnum", "relop", "addop", "multop",
 "assigop", "keyword", "delimiter", "eof"};

char* Scanner::keywords[]=
{ "program", "begin", "end", "integer", "real", "boolean",
  "function", "procedure", "if", "then", "else", "while", "for", "repeat",
  "until", "do", "not", "array", "var", "const", "type", "of" };

// constructor
Scanner::Scanner(char* source)
  : in(source), line_number(1), column_number(0)
  , source_filename(source), state(s_init), prev_state(s_dead)
  , lexemesize(0)
{
  for (int i=0; i<256; i++)
    lexeme[i]=0;
  read_next_char();

  for (int i=0; i<22; i++)
    rw[keywords[i]] = keyword;

  rw["or"] = addop;
  rw["div"] = multop;
  rw["mod"] = multop;
  rw["and"] = multop;
}

// pretty print quadruple of next token in the row
int Scanner::print_next_token(ostream& out) {

  TokenInfo quad = scan();
  out << '(' << token_names[quad.token] << ", '"
      << quad.attributevalue.lexeme << "', "
      << quad.linenumber << ", " << quad.lineposition << ')' << endl;
  //out << "TOKEN: " << lexeme << endl;
}

// The core routine used by the scanner
TokenInfo Scanner::scan() {

  if (state!=s_init) {
    try {
      read_next_char();
    }
    catch (EOFException e) {
      // we may have a valid token up to the end of input
    }
  }
  else if (finished())
    return gen_quad(eof, *new Attribute);

  //cout << state << ",<" << lexeme << "> " << endl; // debug

  // State transitions
  switch (state) {

    // initial state
  case s_init: {

    // beginning position of lexeme
    beg_ln = line_number;
    beg_cn = column_number;

    switch (c) {

      // white space
    case '\n':
    case ' ':
    case '\t': transition(s_ws); scan_white_space(); break;

      // beginning of a comment
    case '{': transition(s_comment); scan_comment(); break;

      // prefix '<'
    case '<': transition(s_less); break;

      // prefix '>'
    case '>': transition(s_grt); break;

      // prefix ':'
    case ':': transition(s_col); break;

      // prefix ','
    case '.': transition(s_dot); break;

      // singletons
    case '=': transition(s_eq); break;
    case '+': transition(s_add); break;
    case '-': transition(s_sub); break;
    case '*': transition(s_tms); break;
    case '/': transition(s_dvd); break;
    case ',': transition(s_cm); break;
    case ';': transition(s_sc); break;
    case '(': transition(s_lb); break;
    case ')': transition(s_rb); break;
    case '[': transition(s_la); break;
    case ']': transition(s_ra); break;
    default: {
      if (isalpha(c))
	transition(s_id);
      else if (isdigit(c))
	transition(s_num);
      else {
	transition(s_init);	// unable to match a token
	error(c + " cannot constitute a token");
     }
    } break;
    }
  }
  break;

  // scanning white space
  case s_ws: {
    switch (c) {
    case '\n':
    case ' ':
    case '\t': break;
    default: {
	transition(s_init);
    } break;
    }
  }
  break;

  // scanning identifiers and keywords
  case s_id: {
    if (!isalnum(c))
      transition(s_init);
  } break;
  break;

  // scanning numbers
  case s_num: {
    if ((c=='.'))
      transition(s_fract);
    else if ((c=='e'))
      transition(s_exp2);
    else if (!isdigit(c))
      transition(s_init);
  } break;
  break;

  // scanning fraction
  case s_fract: {
    if ((c=='e'))
      transition(s_exp);
    else if (!isdigit(c)) {
      transition(s_init);
      if (last_c=='.') {
	cerr << "Digit expected for fraction part of real literal";
	error("Digit expected for fraction part of real literal");
	transition(s_error);
      }
    }
  } break;
  break;

  // scanning optional exponent
  case s_exp: {
    if (! ((isdigit(c)) || (c=='+') || (c=='-')) )
      error("Digit, + or - expected for exponent part of real literal");
    transition(s_exp2);
  } break;
  break;

  // scanning optional exponent's value
  case s_exp2: {
    if (!isdigit(c))
      if (!isdigit(last_c))
	error("Digit expected at the end of exponent part");
      else
	transition(s_init);
  } break;
  break;

  // scanning prefix '<'
  case s_less: {
    switch (c) {
    case '>': transition(s_ne); break;
    case '=': transition(s_le); break;
    default: transition(s_init); break;
    }
  }
  break;
  case s_ne: transition(s_init); break;
  case s_le: transition(s_init); break;

  // scanning prefix '>'
  case s_grt: {
    switch (c) {
    case '=': transition(s_ge); break;
    default: transition(s_init); break;
    }
  }
  break;
  case s_ge: transition(s_init); break;

  // scanning prefix '.'
  case s_dot: {
    switch (c) {
    case '.': transition(s_dotdot); break;
    default: transition(s_init); break;
    }
  }
  break;
  case s_dotdot: transition(s_init); break;

  // scanning prefix ':'
  case s_col: {
    switch (c) {
    case '=': transition(s_asg); break;
    default: transition(s_init); break;
    }
  }
  break;
  case s_asg: transition(s_init); break;

  case s_eq:
  case s_add:
  case s_sub:
  case s_tms:
  case s_dvd:
  case s_cm:
  case s_sc:
  case s_lb:
  case s_rb:
  case s_la:
  case s_ra: transition(s_init); break;
  } // end of switch(state)
  
  // append new character to the lexeme
  if (state!=s_init) {
    lexeme[lexemesize++] = c;
    if (lexemesize==65)
      error("Lexeme too long");
  }
  if (state==s_init) {

    // output token if recognized
    switch (prev_state) {
    case s_id: return handle_id();
    case s_num: return gen_quad(intnum, *new IntNum(lexeme));
    case s_fract:
    case s_exp2: return gen_quad(realnum, *new RealNum(lexeme));
    case s_eq: return gen_quad(relop, *new RelOp);
    case s_ne: return gen_quad(relop, *new RelOp);
    case s_le: return gen_quad(relop, *new RelOp);
    case s_less: return gen_quad(relop, *new RelOp);
    case s_ge: return gen_quad(relop, *new RelOp);
    case s_grt: return gen_quad(relop, *new RelOp);
    case s_add: return gen_quad(addop, *new AddOp);
    case s_sub: return gen_quad(addop, *new AddOp);
    case s_tms: return gen_quad(multop, *new MultOp);
    case s_dvd: return gen_quad(multop, *new MultOp);
    case s_dot: return gen_quad(delimiter, *new Delimiter);
    case s_dotdot: return gen_quad(delimiter, *new Delimiter);
    case s_col: return gen_quad(delimiter, *new Delimiter);
    case s_cm: return gen_quad(delimiter, *new Delimiter);
    case s_sc: return gen_quad(delimiter, *new Delimiter);
    case s_lb: return gen_quad(delimiter, *new Delimiter);
    case s_rb: return gen_quad(delimiter, *new Delimiter);
    case s_la: return gen_quad(delimiter, *new Delimiter);
    case s_ra: return gen_quad(delimiter, *new Delimiter);
    case s_asg: return gen_quad(assigop, *new AssigOp);
    case s_ws:
    case s_comment:
    case s_dead: break;
    default: error("No matching token"); break;// we have fetched no token!
    }
    reset_lexeme();
  }

  return scan();
}

// clear lexeme
void Scanner::reset_lexeme()
{
  for (int i=0; i<lexemesize; i++)		// starting new lexeme
    lexeme[i]=0;
  lexemesize = 0;
}

// read next character from the input stream
void Scanner::read_next_char() {
  if (finished()) {
    cerr << "Already at the end of the input" << endl;
    throw EOFException();
  }

  // read next character from the input stream
  last_c = c;
  c = in.get();
  if (finished()) {
    // return 0
    throw EOFException();
  }

  // update current line and column number
  if (c=='\n') {
    line_number += 1;
    column_number = 0;
  }
  else
    if (c=='\t')
      column_number += 8;
    else
      column_number += 1;

  if (isalpha(c))
    c = tolower(c);

}

// perform state transition
void Scanner::transition(State ns) {
  prev_state = state;
  state = ns;
}

void Scanner::scan_white_space() {}

// scan past comments
void Scanner::scan_comment()
{
  //int err = 0;
  do {
    try {
      read_next_char();
    }
    catch (EOFException e) {
      error("comment delimiter '}' expected at the end of file");
      transition(s_init);
      return;
    }
  } while ( (c!='}') );
  transition(s_init);
  read_next_char();
}

// handle identifiers and reserved words through a reserved word table
TokenInfo Scanner::handle_id()
{
  string id_name(lexeme);

  // is it an identifier?
  if (rw.find(lexeme)==rw.end())
    return gen_quad(id, *new ID);
  else {
    // if it is a reserved word find out its type
    Token tkn = rw[lexeme];
    if (tkn==keyword)
      return gen_quad(keyword, *new Keyword);
    else if (tkn==multop)
      return gen_quad(multop, *new MultOp);
    else
      return gen_quad(addop, *new AddOp);
  }
}

// Generate appropriate quadruple for the token t with attr value a
TokenInfo Scanner::gen_quad(Token t, Attribute& a)
{
  a.lexeme = string(lexeme);
  reset_lexeme();
  return TokenInfo(t,a,beg_ln,beg_cn);
}

// Give error message
void Scanner::error(const string& s) {
  cerr << source_filename << ":L" << line_number << ":C" << column_number
       << " Error: " << s << endl;
}

// Give warning message
void Scanner::warning(const string& s) {
  cerr << source_filename << ":L" << line_number << ":C" << column_number
       << " Warning: " << s << endl;
}

@
