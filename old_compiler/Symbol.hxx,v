head	1.4;
access;
symbols;
locks; strict;
comment	@// @;


1.4
date	97.07.10.17.37.41;	author exa;	state Exp;
branches;
next	1.3;

1.3
date	97.06.03.06.40.03;	author exa;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.13.19.04;	author exa;	state Exp;
branches;
next	1.1;

1.1
date	97.05.29.13.13.34;	author exa;	state Exp;
branches;
next	;


desc
@@


1.4
log
@changed comments
@
text
@/*
** Interface file for Symbol class
**
** eXa/aNaLoG
**
*/

#ifndef Symbol_h
#define Symbol_h 1

#include <String.h>
#include "List.hxx"

// base class for Symbols
// Symbols are used to distinguish entities
class Symbol
{
public:
  String name;

  Symbol() {}			// SymbolTable requires this
  Symbol(String n) : name(n) {}
  virtual ~Symbol() {}		// polymorphic or burst!
  virtual String& str() { return name; } // return a string that denotes name
};

// list of symbols
typedef List<Symbol*> SymbolList;
typedef ListTraversal<Symbol*> SymbolTrav;

#endif











@


1.3
log
@Symbol class is alone again.
@
text
@d14 2
a15 2
// A symbol refers to the name of an entity
// Base class for all symbols
d24 1
a24 1
  virtual String& str() { return name; }
@


1.2
log
@g++-library sucks heavily... damn it! even my scribbled list class works
better than theirs, their shit crashes under -frtti, can you believe it?
and I'm trying to start a meta-level stuff, i need the rtti, holy shit.
@
text
@d2 1
a2 1
** Interface file for symbol class
d8 2
a9 2
#ifndef SYMBOL_H
#define SYMBOL_H 1
d21 1
a21 1
  Symbol() {}
d31 1
a31 32
// Label is simple
class Label : public Symbol
{
public:
  Label() {}
};


// abstract base class for type
class Type
{
public:
  Type()  {}
  virtual int storage() = 0;	// storage requirement of type
};

// single linked list of pointers to Type
typedef List<Type*> TypeList; // we need a list of types
typedef ListTraversal<Type*> TypeTrav;

class Void : public Type
{
  Void() {}
  int storage() { return 0; }	// no storage
};  

class Integer : public Type
{
public:
  Integer() {}
  int storage() { return 4; }
};
a32 6
class Real : public Type
{
public:
  Real() {}
  int storage() { return 8; }
};
a34 6
// Variable has name, type, address attributes
class Variable : public Symbol
{
public:
  Type *type;
  int offset; 
a35 3
  Variable(String n, Type *t, int o) : Symbol(n), type(t), offset(o) {}
  virtual ~Variable() {}
};
a37 6
// A Constant is a Variable whose value is statically bound
class Constant : public Variable
{
public:
  void *value;
  String s;
a38 13
  Constant(String n, Type *t, int o, void* v)
    : Variable(n, t, o), value(v) {}
  ~Constant() { delete value; }
  String& str() {
    void *val=value;
    s = "0x";
    for (int i = 0; i < type->storage(); i++, val++) {
      char c = *((char*)val) + '0';
      s += String(c);
    }
    return s;
  }
};
a39 1
#endif
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
#include <SLList.h>
d28 2
a29 2
typedef SLList<Symbol*> SymbolList;

d48 2
a49 1
typedef SLList<Type*> TypeList; // we need a list of types
@
