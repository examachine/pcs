head	1.2;
access;
symbols;
locks; strict;
comment	@// @;


1.2
date	97.06.03.06.45.35;	author exa;	state Exp;
branches;
next	1.1;

1.1
date	97.05.29.17.32.25;	author exa;	state Exp;
branches;
next	;


desc
@@


1.2
log
@do you understand type at all?
@
text
@/*
** Interface file for Type class
**
** eXa/aNaLoG
**
*/


#ifndef Type_h
#define Type_h 1

#include "List.hxx"
class Gen;
class Variable;

// abstract base class for type
// a type is not a symbol, strange?
class Type
{
public:
  Type() {}
  virtual ~Type() {}

  virtual int storage() = 0;	// storage requirement of type
  virtual void declare_local(Gen*, Variable*) {}
};

// list of pointers to Type
typedef List<Type*> TypeList; // we need a list of types
typedef ListTraversal<Type*> TypeTrav;

class Void : public Type
{
public:
  Void() {}

  int storage() { return 0; }	// no storage
  void declare_local(Gen* g, Variable* v);
};

class IntegerType : public Type
{
public:
  IntegerType() {}

  int storage() { return 4; }
  void declare_local(Gen* g, Variable* v);
};

class RealType : public Type
{
public:
  RealType() {}

  int storage() { return 8; }
  void declare_local(Gen* g, Variable* v);
};


#endif































@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
** Interface file for
d8 1
d12 2
a13 2
#include "Gen.hxx"

d21 3
a23 1
  Type()  {}
d25 1
a25 1
  virtual void gen(Gen& g, Variable* v) {}
d28 1
a28 1
// single linked list of pointers to Type
d34 1
d36 1
d38 2
a39 1
};  
d41 1
a41 1
class Integer : public Type
d44 2
a45 1
  Integer() {}
d47 1
a47 1
  void gen(Gen& g, Variable* v) { g.add(local, 1, 0, v->name); }
d50 1
a50 1
class Real : public Type
d53 2
a54 1
  Real() {}
d56 1
a56 1
  void gen(Gen& g, Variable* v) { g.add(localf, 1, 0, v->name); }
d59 1
d61 22
@
