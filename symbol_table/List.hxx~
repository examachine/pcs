/*
**
** generic linked list class
**
** exa/analog
**
*/

#ifndef LIST_H
#define LIST_H

#include <stdlib.h>

template<class T>
class List;

template<class T>
class Traversal;

template <class T>
class ListNode
{
 public:
  friend class List<T>;
  
  // constructors
  ListNode<T>() : succ(NULL), pred(NULL) {}
  ListNode<T>(ListNode<T> s, ListNode<T> p, <T> c)
    : succ(s), pred(p), content(c) {}

  // destructor
  ~ListNode<T>() {}
  void rem() {
    if (succ)
        succ->pred=pred;
    if (pred)
        pred->succ=succ;
    delete this;
  }

  <T>  get() { return content; }
  }

 private:
  ListNode<T> *succ;
  ListNode<T> *pred;
  <T>         content;
};


template <class T>
class List
{
public:
  friend ListNode<T>;

  List<T>() : head(NULL), tail(NULL);
  ~List<T>() {
    ListNode<T> *node=head, *next;
    while (node) {
      next=node->succ;
      delete node;
      node=next;
    }
  }

  int is_empty() { return head==NULL; }
  
  void insert( ListNode<T> *node, ListNode<T> *pred) {
    ListNode<T> *succ;	/* successor of the node to insert */
    
    if (pred==NULL)		/* is it an add_head? */
      this.add_head(node);
    else if (pred==tail)	/* an add_tail? */
      this.add_tail(node);
    else {
      succ=pred->succ;	/* let's find that successor*/
      pred->succ=node;	/* and link the three together */
      node->pred=pred;
      node->succ=succ;
      succ->pred=node;
    }
  }

  void add_head( <T> c) {
    ListNode<T> *node = new ListNode<T>(head, NULL, c);
    head=node;
    if (tail)
      node->succ->pred=node;
    else
      tail=node;
  }
  
  void add_tail( <T> ) {
    ListNode<T> *node = new ListNode<T>(NULL, tail, c);
    tail=node;
    if (head)
      node->pred->succ=node;
    else
      head=node;
  }
  
  <T> rem_head() {
    ListNode<T> *node;
    <T> content;
    
    node=head;
    if (node) {
      if (tail!=node)
	head=node->succ;
      else
	head=tail=NULL;
      content=node->content;
      delete node;
      return(content);
    }
    else
      return NULL;
  }
  
  <T> rem_tail() {
    ListNode<T> *node;
    <T> content;
    
    node=tail;
    if (node) {
      if (head!=node)
	tail=node->pred;
      else
	head=tail=NULL;
      content=node->content;
      delete node;
      return(content);
    }
    else
      return NULL;
  }
  
  ListNode<T> *get_head() { return head->get(); }
  ListNode<T> *get_tail() { return tail->get(); }

  ListTraversal<T> head() { return ListTraversal<T>(head); }
  ListTraversal<T> tail() { return ListTraversal<T>(tail); }
  
 private:
  ListNode<T> *head;
  ListNode<T> *tail;
  
};

template <class T>
class ListTraversal
{
  ListNode<T> *node;

 public:
  ListTraversal<T>() {}
  ListTraversal<T>(ListNode<T> *n) : node(n) {}

  void succ() { node = node->succ; }
};

#endif

